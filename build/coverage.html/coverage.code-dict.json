{"/home/travis/build/npmtest/node-npmtest-baucis/test.js":"/* istanbul instrument in package npmtest_baucis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-baucis/lib.npmtest_baucis.js":"/* istanbul instrument in package npmtest_baucis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_baucis = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_baucis = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-baucis/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-baucis && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_baucis */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_baucis\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_baucis.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_baucis.rollup.js'] =\n            local.assetsDict['/assets.npmtest_baucis.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_baucis.__dirname + '/lib.npmtest_baucis.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/index.js":"// __Dependencies__\nvar deco = require('deco');\nvar es = require('event-stream');\nvar mongoose = require('mongoose');\nvar Api = require('./Api');\nvar Controller = require('./Controller');\nvar Model = require('./Model');\nvar RestError = require('rest-error');\nvar plugins = {\n  json: require('baucis-json'),\n  links: require('baucis-links')\n};\n\nvar instance;\nvar parsers = {};\nvar formatters = {};\nvar errorFormatters = {};\n\n// __Module Definition__\nvar baucis = module.exports = function (options) {\n  return baucis.empty();\n};\n\n// __Public Members__\nbaucis.rest = function (model) {\n  if (!instance) instance = Api();\n  return instance.rest(model);\n};\n\nbaucis.empty = function () {\n  var previous = instance;\n  instance = Api();\n  return previous;\n};\n\nbaucis.formatters = function (response, callback) {\n  // if (response._headerSent) {\n  //   callback(null, function () {\n  //     return es.through(function (data) { console.log(data) }, function () {\n  //       this.emit('end');\n  //     });\n  //   });\n  //   return;\n  // }\n\n  var handlers = {\n    default: function () {\n      callback(RestError.NotAcceptable());\n    }\n  };\n\n  Object.keys(formatters).map(function (mime) {\n    handlers[mime] = formatters[mime](callback);\n  });\n  response.format(handlers);\n};\n\n// Adds a formatter for the given mime type.  Needs a function that returns a stream.\nbaucis.setFormatter = function (mime, f) {\n  formatters[mime] = function (callback) { return function () { callback(null, f) } };\n  return baucis;\n};\n\nbaucis.parser = function (mime, handler) {\n  // Default to JSON when no MIME type is provided.\n  mime = mime || 'application/json';\n  // Not interested in any additional parameters at this point.\n  mime = mime.split(';')[0].trim();\n  var handler = parsers[mime];\n  return handler ? handler() : undefined;\n};\n\n// Adds a parser for the given mime type.  Needs a function that returns a stream.\nbaucis.setParser = function (mime, f) {\n  parsers[mime] = f;\n  return baucis;\n};\n\n// __Expose Modules__\nbaucis.Api = Api;\nbaucis.Controller = Controller;\nbaucis.Error = RestError;\nbaucis.Model = Model;\n\nApi.container(baucis);\nController.container(baucis);\nRestError.container(baucis);\nModel.container(baucis);\n\n// __Plugins__\nplugins.json.apply(baucis);\nplugins.links.apply(baucis);\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Api/index.js":"// __Dependencies__\nvar deco = require('deco');\nvar semver = require('semver');\nvar express = require('express');\nvar Controller = require('../Controller');\nvar RestError = require('rest-error');\n\n// __Module Definition__\nvar Api = module.exports = deco(function (options, protect) {\n  var api = this;\n\n  api.use(function (request, response, next) {\n    if (request.baucis) return next(RestError.Misconfigured('Baucis request property already created'));\n\n    request.baucis = {};\n    response.removeHeader('x-powered-by');\n    // Any caching proxies should be aware of API version.\n    response.vary('API-Version');\n    // TODO move this\n    // Requested range is used to select highest possible release number.\n    // Then later controllers are checked for matching the release number.\n    var version = request.headers['api-version'] || '*';\n    // Check the requested API version is valid.\n    if (!semver.validRange(version)) {\n      next(RestError.BadRequest('The requested API version range \"%s\" was not a valid semver range', version));\n      return;\n    }\n\n    request.baucis.release = semver.maxSatisfying(api.releases(), version);\n    // Check for API version unsatisfied and give a 400 if no versions match.\n    if (!request.baucis.release) {\n      next(RestError.BadRequest('The requested API version range \"%s\" could not be satisfied', version));\n      return;\n    }\n\n    response.set('API-Version', request.baucis.release);\n    next();\n  });\n\n  // __Public Members___\n  protect.property('releases', [ '0.0.1' ], function (release) {\n    if (!semver.valid(release)) {\n      throw RestError.Misconfigured('Release version \"%s\" is not a valid semver version', release);\n    }\n    return this.releases().concat(release);\n  });\n\n  api.rest = function (model) {\n    var controller = Controller(model);\n    api.add(controller);\n    return controller;\n  };\n});\n\nApi.factory(express.Router);\nApi.decorators(__dirname, ['controllers']);\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/index.js":"// __Dependencies__\nvar deco = require('deco');\nvar express = require('express');\nvar RestError = require('rest-error');\n\n// __Module Definition__\nvar Controller = module.exports = deco();\n\nController.factory(express.Router);\nController.decorators(__dirname, [\n  'configure',\n  'stages',\n  'activation',\n  'request',\n  'query',\n  'send',\n  'errors'\n]);\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/configure.js":"// __Dependencies__\nvar mongoose = require('mongoose');\nvar semver = require('semver');\nvar Model = require('../Model');\nvar RestError = require('rest-error');\n\n// __Module Definition__\nvar decorator = module.exports = function (model, protect) {\n  var controller = this;\n\n  if (typeof model !== 'string' && (!model || !model.schema)) {\n    throw RestError.Misconfigured('You must pass in a model or model name');\n  }\n\n  // __Property Definitions__\n  protect.property('comments', false);\n  protect.property('explain', false);\n  protect.property('hints', false);\n  protect.property('select', '');\n  protect.property('sort', '');\n\n  protect.property('versions', '*', function (range) {\n    if (semver.validRange(range)) return range;\n    throw RestError.Misconfigured('Controller version range \"%s\" was not a valid semver range', range);\n  });\n\n  protect.property('model', undefined, function (m) { // TODO readonly\n    if (typeof m === 'string') return mongoose.model(m);\n    return m;\n  });\n\n  protect.property(\n    'fragment',\n    function (value) {\n      if (value === undefined) return '/' + controller.model().plural();\n      if (value.indexOf('/') !== 0) return '/' + value;\n      return value;\n    }\n  );\n\n  protect.property('findBy', '_id', function (path) {\n    var findByPath = controller.model().schema.path(path);\n    if (!findByPath.options.unique && !(findByPath.options.index && findByPath.options.index.unique)) {\n      throw RestError.Misconfigured('`findBy` path for model \"%s\" must be unique', controller.model().modelName);\n    }\n    return path;\n  });\n\n  protect.multiproperty('operators', undefined, false);\n  protect.multiproperty('methods', 'head get put post delete', true, function (enabled) {\n    return enabled ? true : false;\n  });\n\n  controller.deselected = function (path) {\n    var deselected = controller.model().deselected();\n    // Add deselected paths from the controller.\n    controller.select().split(/\\s+/).forEach(function (path) {\n      var match = /^(?:[-]((?:[\\w]|[-])+)\\b)$/.exec(path);\n      if (match) deselected.push(match[1]);\n    });\n    var deduplicated = deselected.filter(function(path, position) {\n      return deselected.indexOf(path) === position;\n    });\n\n    if (arguments.length === 0) return deduplicated;\n    else return (deduplicated.indexOf(path) !== -1);\n  };\n\n  // Set the controller model.\n  controller.model(model);\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Model.js":"var deco = require('deco');\nvar mongoose = require('mongoose');\nvar pluralize = require('mongoose/lib/utils').toCollectionName;\n\nvar Model = module.exports = deco(function (options, protect) {\n  var model = this;\n\n  protect.property('singular');\n  protect.property('plural');\n  protect.property('locking', false);\n  protect.property('lastModified');\n\n  model.deselected = function (path) {\n    var deselected = [];\n    // Store naming, model, and schema.\n    // Find deselected paths in the schema.\n    model.schema.eachPath(function (name, path) {\n      if (path.options.select === false) deselected.push(name);\n    });\n    if (arguments.length === 0) return deselected;\n    else return (deselected.indexOf(path) !== -1);\n  };\n\n  model.singular(model.modelName);\n  model.plural(pluralize(model.singular()));\n});\n\n// Wrap the mongoose model function to add this mixin to all registered models.\nvar originalMongooseModel = mongoose.model;\nmongoose.model = function () {\n  var m = originalMongooseModel.apply(mongoose, arguments);\n  if (!m.singular) Model.apply(m);\n  return m;\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/stages.js":"// __Dependencies__\nvar express = require('express');\n\n// __Module Definition__\nvar decorator = module.exports = function (options, protect) {\n  var controller = this;\n  var initial = express.Router();\n  var controllerForStage = protect.controllerForStage = {\n    initial: initial,\n    request: express.Router(),\n    query: express.Router(),\n    finalize: express.Router()\n  };\n  // __Stage Controllers__\n  controller.use(initial);\n  controller.use(controllerForStage.request);\n  controller.use(controllerForStage.query);\n  controller.use(controllerForStage.finalize);\n  // Expose the original `use` function as a protected method.\n  protect.use = controller.use.bind(controller);\n  // Pass the method calls through to the \"initial\" stage middleware controller,\n  // so that it precedes all other stages and middleware that might have been\n  // already added.\n  controller.use = initial.use.bind(initial);\n  controller.all = initial.all.bind(initial);\n  controller.head = initial.head.bind(initial);\n  controller.get = initial.get.bind(initial);\n  controller.post = initial.post.bind(initial);\n  controller.put = initial.put.bind(initial);\n  controller.delete = initial.delete.bind(initial);\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/activation.js":"// __Dependencies__\nvar RestError = require('rest-error');\nvar Controller = require('../Controller');\n// __Private Module Members__\n// Expands route definitions based on generalized arguments.\nvar defineRoutes = function (stage, params) {\n  var options;\n  var argumentsArray = Array.prototype.slice.call(params);\n\n  options = last(0, ['endpoint', 'methods', 'middleware'], argumentsArray);\n  options.stage = stage;\n\n  return factor(options);\n}\n// A filter function for checking a given value is defined and not null.\nfunction exists (o) { return o !== undefined && o !== null }\n// Handle variable number of arguments\nfunction last (skip, names, values) {\n  var r = {};\n  var position = names.length;\n  var count = values.filter(exists).length - skip;\n  if (count < 1) throw RestError.Misconfigured('Too few arguments.');\n\n  names.forEach(function (name) {\n    var index = skip + count - position;\n    position--;\n    if (index >= skip) r[name] = values[index];\n  });\n\n  return r;\n}\n// Returns `true` if the given stirng is a recognized HTTP method.\nfunction isRecognizedMethod (s) {\n  return /^all|head|get|put|post|delete$/.exec(s) ? true : false;\n}\n// Parse middleware into an array of middleware definitions for each endpoint and method\nfunction factor (options) {\n  var factored = [];\n  var methodString = options.methods;\n  var methods;\n\n  if (methodString) methodString = methodString.toLowerCase();\n\n  if (!methodString || methodString === '*') methodString = 'all';\n  methods = methodString.split(/\\s+/);\n\n  methods.forEach(function (method) {\n    if (!isRecognizedMethod(method)) throw RestError.Misconfigured('Unrecognized HTTP method: \"%s\"', method);\n  });\n\n  if (!options.stage) throw RestError.Misconfigured('The middleware stage was not provided');\n  if (options.endpoint && options.endpoint !== 'instance' && options.endpoint !== 'collection') {\n    throw RestError.Misconfigured('End-point type must be either \"instance\" or \"collection,\" not \"%s\"', options.endpoint);\n  }\n  // Middleware function or array\n  if (!Array.isArray(options.middleware) && typeof options.middleware !== 'function') {\n    throw RestError.Misconfigured('Middleware must be an array or function');\n  }\n  // Check endpoint is valid\n  if (options.endpoint !== undefined && options.endpoint !== 'instance' && options.endpoint !== 'collection') {\n    throw RestError.Misconfigured('End-point type must be either \"instance\" or \"collection,\" not \"%s\"', options.endpoint);\n  }\n  // Add definitions for one or both endpoints, for each HTTP method.\n  methods.forEach(function (method) {\n    if (options.endpoint !== 'collection') factored.push({ stage: options.stage, endpoint: 'instance', method: method, middleware: options.middleware });\n    if (options.endpoint !== 'instance') factored.push({ stage: options.stage, endpoint: 'collection', method: method, middleware: options.middleware });\n  });\n\n  return factored;\n}\n// __Module Definition__\nvar decorator = module.exports = function (options, protect) {\n  var controller = this;\n  // __Private Instance Members__\n  // A method used to activate middleware for a particular stage.\n  function activate (definition) {\n    var stage = protect.controllerForStage[definition.stage];\n    var f = stage[definition.method].bind(stage);\n    if (definition.endpoint === 'instance') f('/:id', definition.middleware);\n    else f('/', definition.middleware);\n  }\n  // __Protected Instance Members__\n  protect.finalize = function (endpoint, methods, middleware) {\n    defineRoutes('finalize', arguments).forEach(activate);\n    return controller;\n  };\n  // __Public Instance Members__\n  // A method used to activate request-stage middleware.\n  controller.request = function (endpoint, methods, middleware) {\n    defineRoutes('request', arguments).forEach(activate);\n    return controller;\n  };\n  // A method used to activate query-stage middleware.\n  controller.query = function (endpoint, methods, middleware) {\n    defineRoutes('query', arguments).forEach(activate);\n    return controller;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/request/index.js":"// __Dependencies__\nvar deco = require('deco');\n\n// __Module Definition__\nvar middleware = module.exports = deco(__dirname, [\n  'allow',\n  'validation',\n  'conditions',\n  'streams'\n]);\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/request/allow.js":"// __Module Definition__\nvar decorator = module.exports = function () {\n  var controller = this;\n  // Build the \"Allow\" response header\n  controller.request(function (request, response, next) {\n    var active = ['head', 'get', 'post', 'put', 'delete'].filter(function (method) {\n      return controller.methods(method) !== false;\n    });\n    var allowed = active.map(function (verb) {\n      return verb.toUpperCase();\n    });\n    response.set('Allow', allowed.join());\n    next();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/request/validation.js":"// __Dependencies__\nvar util = require('util');\nvar RestError = require('rest-error');\n\n// __Module Definition__\nvar decorator = module.exports = function (options, protect) {\n  var controller = this;\n  var check = ['ObjectID', 'Number'];\n\n  protect.isInvalid = function (id, instance, type) {\n    var error;\n    if (!id) return false;\n    if (check.indexOf(instance) === -1) return false;\n    if (instance === 'ObjectID' && id.match(/^[a-f0-9]{24}$/i)) return false;\n    if (instance === 'Number' && !isNaN(Number(id))) return false;\n    return true;\n  };\n\n  // Validate URL's ID parameter, if any.\n  controller.request(function (request, response, next) {\n    var id = request.params.id;\n    var instance = controller.model().schema.path(controller.findBy()).instance;\n    var invalid = protect.isInvalid(request.params.id, instance, 'url.id');\n    if (!invalid) return next();\n    next(RestError.BadRequest('The requested document ID \"%s\" is not a valid document ID', id));\n  });\n\n  // Check that the HTTP method has not been disabled for this controller.\n  controller.request(function (request, response, next) {\n    var method = request.method.toLowerCase();\n    if (controller.methods(method) !== false) return next();\n    next(RestError.MethodNotAllowed('The requested method has been disabled for this resource'));\n  });\n\n  // Treat the addressed document as a collection, and push the addressed object\n  // to it.  (Not implemented.)\n  controller.request('instance', 'post', function (request, response, next) {\n    return next(RestError.NotImplemented('Cannot POST to an instance'));\n  });\n\n  // Update all given docs.  (Not implemented.)\n  controller.request('collection', 'put', function (request, response, next) {\n    return next(RestError.NotImplemented('Cannot PUT to the collection'));\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/request/conditions.js":"var RestError = require('rest-error');\n\n// __Module Definition__\nvar decorator = module.exports = function () {\n  var controller = this;\n  // Set the conditions used for finding/updating/removing documents.\n  this.request(function (request, response, next) {\n    var conditions = request.query.conditions || {};\n\n    if (typeof conditions === 'string') {\n      try {\n        conditions = JSON.parse(conditions);\n      }\n      catch (exception) {\n        next(RestError.BadRequest('The conditions query string value was not valid JSON: \"%s\"', exception.message));\n        return;\n      }\n    }\n\n    if (conditions.$explain && !controller.explain()) {\n      return next(RestError.BadRequest('Using $explain is disabled for this resource'));\n    }\n\n    if (request.params.id !== undefined) {\n      conditions[controller.findBy()] = request.params.id;\n    }\n\n    request.baucis.conditions = conditions;\n    next();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/request/streams.js":"// __Dependencies__\nvar es = require('event-stream');\nvar domain = require('domain');\n\n// __Module Definition__\nvar decorator = module.exports = function (options, protect) {\n  // __Protected Module Members__\n  // A utility method for ordering through streams.\n  protect.pipeline = function (handler) {\n    var streams = [];\n    var d = domain.create();\n    d.on('error', handler);\n    return function (transmute) {\n      // If it's a stream, add it to the reserve pipeline.\n      if (transmute && (transmute.writable || transmute.readable)) {\n        streams.push(transmute);\n        d.add(transmute);\n        return transmute;\n      }\n      // If it's a function, create a map stream with it.\n      if (transmute) {\n        transmute = es.map(transmute);\n        streams.push(transmute);\n        d.add(transmute);\n        return transmute;\n      }\n      // If called without arguments, return a pipeline linking all streams.\n      if (streams.length > 0) {\n        return d.run(function() {\n          return es.pipeline.apply(es, streams);\n        });\n      }\n      // But, if no streams were added, just pass back a through stream.\n      return d.run(es.through);\n    };\n  };\n  // __Middleware__\n  // Create the pipeline interface the user interacts with.\n  this.request(function (request, response, next) {\n    request.baucis.incoming = protect.pipeline(next);\n    request.baucis.outgoing = protect.pipeline(next);\n    next();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/query/index.js":"// __Dependencies__\nvar deco = require('deco');\n\n// __Module Definition__\nvar middleware = module.exports = deco(__dirname, [\n  // __Query-Stage Middleware__\n  'create',\n  'update',\n  'build',\n  'options'\n]);\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/query/create.js":"// __Dependencies__\nvar es = require('event-stream');\nvar util = require('util');\nvar domain = require('domain');\nvar RestError = require('rest-error');\n\n// __Module Definition__\nvar decorator = module.exports = function (options, protect) {\n  var baucis = require('../..');\n  var controller = this;\n\n  controller.query('post', function (request, response, next) {\n    var url = request.originalUrl || request.url;\n    var findBy = controller.findBy();\n    var pipeline = protect.pipeline(next);\n    var parser;\n    // Add trailing slash to URL if needed.\n    if (url.lastIndexOf('/') === (url.length - 1)) url = url.slice(0, url.length - 1);\n    // Set the status to 201 (Created).\n    response.status(201);\n    // Check if the body was parsed by some external middleware e.g. `express.json`.\n    // If so, create a stream from the POST'd document or documents.\n    if (request.body) {\n      pipeline(es.readArray([].concat(request.body)));\n    }\n    // Otherwise, stream and parse the request.\n    else {\n      parser = baucis.parser(request.get('content-type'));\n      if (!parser) return next(RestError.UnsupportedMediaType());\n      pipeline(request);\n      pipeline(parser);\n    }\n    // Create the stream context.\n    pipeline(function (incoming, callback) {\n      callback(null, { incoming: incoming, doc: null });\n    });\n    // Process the incoming document or documents.\n    pipeline(request.baucis.incoming());\n    // Map function to create a document from incoming JSON and update the context.\n    pipeline(function (context, callback) {\n      var transformed = { incoming: context.incoming };\n      var Model = controller.model();\n      var type = context.incoming.__t;\n      var Discriminator = type ? Model.discriminators[type] : undefined;\n      if (type && !Discriminator) {\n        callback(RestError.UnprocessableEntity({\n          message: \"A document's type did not match any known discriminators for this resource\",\n          name: 'RestError',\n          path: '__t',\n          value: type\n        }));\n        return;\n      }\n      // Create the document using either the model or child model.\n      if (type) transformed.doc = new Discriminator();\n      else transformed.doc = new Model();\n      // Transformation complete.\n      callback(null, transformed);\n    });\n    // Update the new Mongoose document with the incoming data.\n    pipeline(function (context, callback) {\n      context.doc.set(context.incoming);\n      callback(null, context);\n    });\n    // Save each document.\n    pipeline(function (context, callback) {\n      context.doc.save(function (error, doc) {\n        if (error) return next(error);\n        callback(null, { incoming: context.incoming, doc: doc });\n      });\n    });\n    // Map the saved documents to document IDs.\n    pipeline(function (context, callback) {\n      callback(null, context.doc.get(findBy));\n    });\n    // Write the IDs to an array and process them.\n    var s = pipeline();\n    s.pipe(es.writeArray(function (error, ids) {\n      if (error) return next(error);\n      // URL location of newly created document or documents.\n      var location;\n      // Set the conditions used to build `request.baucis.query`.\n      var conditions = request.baucis.conditions[findBy] = { $in: ids };\n      // Check for at least one document.\n      if (ids.length === 0) {\n        next(RestError.UnprocessableEntity({\n          message: 'The request body must contain at least one document',\n          name: 'RestError'\n        }));\n        return;\n      }\n      // Set the `Location` header if at least one document was sent.\n      if (ids.length === 1) location = url + '/' + ids[0];\n      else location = util.format('%s?conditions={ \"%s\": %s }', url, findBy, JSON.stringify(conditions));\n      response.set('Location', location);\n      next();\n    }));\n    s.resume();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/query/update.js":"// __Dependencies__\nvar express = require('express');\nvar util = require('util');\nvar es = require('event-stream');\nvar RestError = require('rest-error');\n\n// __Private Module Members__\nvar validOperators = [ '$set', '$push', '$pull', '$addToSet', '$pop', '$pushAll', '$pullAll' ];\n\n// __Module Definition__\nvar decorator = module.exports = function (options, protect) {\n  var baucis = require('../..');\n  var controller = this;\n\n  function checkBadUpdateOperatorPaths (operator, paths) {\n    var bad = false;\n    var whitelisted = controller.operators(operator);\n    var parts;\n\n    if (!whitelisted) return true;\n\n    parts = whitelisted.split(/\\s+/);\n\n    paths.forEach(function (path) {\n      if (parts.indexOf(path) !== -1) return;\n      bad = true;\n    });\n\n    return bad;\n  }\n\n  // If there's a body, send it through any user-added streams.\n  controller.query('instance', 'put', function (request, response, next) {\n    var parser;\n    var count = 0;\n    var operator = request.headers['update-operator'];\n    var versionKey = controller.model().schema.get('versionKey');\n    var pipeline = protect.pipeline(next);\n    // Check if the body was parsed by some external middleware e.g. `express.json`.\n    // If so, create a one-document stream from the parsed body.\n    if (request.body) {\n      pipeline(es.readArray([ request.body ]));\n    }\n    // Otherwise, stream and parse the request.\n    else {\n      parser = baucis.parser(request.get('content-type'));\n      if (!parser) return next(RestError.UnsupportedMediaType());\n      pipeline(request);\n      pipeline(parser);\n    }\n    // Set up the stream context.\n    pipeline(function (body, callback) {\n      var context = { doc: undefined, incoming: body };\n      callback(null, context);\n    });\n    // Load the Mongoose document and add it to the context, unless this is a\n    // special update operator.\n    if (!operator) {\n      pipeline(function (context, callback) {\n        var query = controller.model().findOne(request.baucis.conditions);\n        query.exec(function (error, doc) {\n          if (error) return callback(error);\n          if (!doc) return callback(RestError.NotFound());\n          // Add the Mongoose document to the context.\n          callback(null, { doc: doc, incoming: context.incoming });\n        });\n      });\n    }\n    // Pipe through user streams, if any.\n    pipeline(request.baucis.incoming());\n    // If the document ID is present, ensure it matches the ID in the URL.\n    pipeline(function (context, callback) {\n      var bodyId = context.incoming[controller.findBy()];\n      if (bodyId === undefined) return callback(null, context);\n      if (bodyId === request.params.id) return callback(null, context);\n      callback(RestError.UnprocessableEntity({\n        message: \"The ID of the update document did not match the URL's document ID.\",\n        name: 'RestError',\n        path: controller.findBy(),\n        value: bodyId\n      }));\n    });\n    // Ensure the request includes a finite object version if locking is enabled.\n    if (controller.model().locking()) {\n      pipeline(function (context, callback) {\n        var updateVersion = context.incoming[versionKey];\n        if (updateVersion === undefined || !Number.isFinite(Number(updateVersion))) {\n          callback(RestError.UnprocessableEntity({\n            message: 'Locking is enabled, but the target version was not provided in the request body.',\n            name: 'RestError',\n            path: versionKey\n          }));\n          return;\n        }\n        callback(null, context);\n      });\n      // Add some locking checks only applicable to the default update operator.\n      if (!operator) {\n        // Make sure the version key was selected.\n        pipeline(function (context, callback) {\n          if (!context.doc.isSelected(versionKey)) {\n            callback(RestError.BadRequest('The version key \"%s\" must be selected', versionKey));\n            return;\n          }\n          // Pass through.\n          callback(null, context);\n        });\n        pipeline(function (context, callback) {\n          var updateVersion = Number(context.incoming[versionKey]);\n          // Update and current version have been found.  Check if they're equal.\n          if (updateVersion !== context.doc[versionKey]) return callback(RestError.LockConflict());\n          // One is not allowed to set __v and increment in the same update.\n          delete context.incoming[versionKey];\n          context.doc.increment();\n          // Pass through.\n          callback(null, context);\n        });\n      }\n    }\n    // Ensure there is exactly one update document.\n    pipeline(es.through(\n      function (context) {\n        count += 1;\n        if (count === 2) {\n          this.emit('error', RestError.UnprocessableEntity({\n            message: 'The request body contained more than one update document',\n            name: 'RestError'\n          }));\n          return;\n        }\n        if (count > 1) return;\n\n        this.emit('data', context);\n      },\n      function () {\n        if (count === 0) {\n          this.emit('error', RestError.UnprocessableEntity({\n            message: 'The request body did not contain an update document',\n            name: 'RestError'\n          }));\n          return;\n        }\n        this.emit('end');\n      }\n    ));\n    // Finish up for the default update operator.\n    if (!operator) {\n      // Update the Mongoose document with the request body.\n      pipeline(function (context, callback) {\n        context.doc.set(context.incoming);\n        // Pass through.\n        callback(null, context);\n      });\n      // Save the Mongoose document.\n      pipeline(function (context, callback) { context.doc.save(callback); });\n    }\n    // Finish up for a non-default update operator (bypasses validation).\n    else {\n      pipeline(function (context, callback) {\n        var wrapper = {};\n\n        if (validOperators.indexOf(operator) === -1) {\n          callback(RestError.NotImplemented('The requested update operator \"%s\" is not supported', operator));\n          return;\n        }\n        // Ensure that some paths have been enabled for the operator.\n        if (!controller.operators(operator)) {\n          callback(RestError.Forbidden('The requested update operator \"%s\" is not enabled for this resource', operator));\n          return;\n        }\n        // Make sure paths have been whitelisted for this operator.\n        if (checkBadUpdateOperatorPaths(operator, Object.keys(context.incoming))) {\n          callback(RestError.Forbidden('This update path is forbidden for the requested update operator \"%s\"', operator));\n          return;\n        }\n\n        wrapper[operator] = context.incoming;\n        if (controller.model().locking()) {\n          request.baucis.conditions[versionKey] = Number(context.incoming[versionKey]);\n        }\n        // Update the doc using the supplied operator and bypassing validation.\n        controller.model().update(request.baucis.conditions, wrapper, callback);\n      });\n    }\n\n    var s = pipeline();\n    s.on('end', next);\n    s.resume();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/query/build.js":"// __Module Definition__\nvar decorator = module.exports = function () {\n  var controller = this;\n\n  controller.query('collection', '*', function (request, response, next) {\n    request.baucis.query = controller.model().find(request.baucis.conditions);\n    next();\n  });\n\n  controller.query('instance', '*', function (request, response, next) {\n    request.baucis.query = controller.model().findOne(request.baucis.conditions);\n    next();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/query/options.js":"// __Dependencies__\nvar RestError = require('rest-error');\n\n// __Private Methods__\nfunction isDefinedAndNotNull (n) {\n  if (n === null) return false;\n  if (n === undefined) return false;\n  return true;\n}\n\nfunction isPositiveInteger (n) {\n  if (!isDefinedAndNotNull(n)) return false;\n  n = Number(n);\n  if (n < 1) return false;\n  return n === Math.ceil(n);\n}\n\nfunction getAsInt(n) {\n\treturn Math.ceil(Number(n));\n}\n\nfunction isNonNegativeInteger (n) {\n  if (!isDefinedAndNotNull(n)) return false;\n  n = Number(n);\n  if (n < 0) return false;\n  return n === Math.ceil(n);\n}\n\n// __Module Definition__\nvar decorator = module.exports = function () {\n  var controller = this;\n\n  function checkBadSelection (select) {\n    var bad = false;\n    controller.deselected().forEach(function (path) {\n      var badPath = new RegExp('[+]?' + path + '\\\\b', 'i');\n      if (badPath.exec(select)) bad = true;\n    });\n    return bad;\n  }\n\n  // Perform distinct query.\n  this.query(function (request, response, next) {\n    var distinct = request.query.distinct;\n    if (!distinct) return next();\n    if (controller.deselected(distinct)) {\n      next(RestError.Forbidden('You may not find distinct values for the requested path'));\n      return;\n    }\n    var query = controller.model().distinct(distinct, request.baucis.conditions);\n    query.exec(function (error, values) {\n      if (error) return next(error);\n      request.baucis.documents = values;\n      next();\n    });\n  });\n  // Apply controller sort options to the query.\n  this.query(function (request, response, next) {\n    var sort = controller.sort();\n    if (sort) request.baucis.query.sort(sort);\n    next();\n  });\n  // Apply incoming request sort.\n  this.query(function (request, response, next) {\n    var sort = request.query.sort;\n    if (sort) request.baucis.query.sort(sort);\n    next();\n  });\n  // Apply controller select options to the query.\n  this.query(function (request, response, next) {\n    var select = controller.select();\n    if (select) request.baucis.query.select(select);\n    next();\n  });\n  // Apply incoming request select to the query.\n  this.query(function (request, response, next) {\n    var select = request.query.select;\n    if (!select) return next();\n\n    if (select.indexOf('+') !== -1) {\n      return next(RestError.Forbidden('Including excluded fields is not permitted'));\n    }\n    if (checkBadSelection(select)) {\n      return next(RestError.Forbidden('Including excluded fields is not permitted'));\n    }\n\n    request.baucis.query.select(select);\n    next();\n  });\n  // Apply incoming request populate.\n  this.query(function (request, response, next) {\n    var populate = request.query.populate;\n    var allowPopulateSelect = request.baucis.allowPopulateSelect;\n    var error = null;\n\n    if (populate) {\n      if (typeof populate === 'string') {\n        if (populate.indexOf('{') !== -1) populate = JSON.parse(populate);\n        else if (populate.indexOf('[') !== -1) populate = JSON.parse(populate);\n      }\n\n      if (!Array.isArray(populate)) populate = [ populate ];\n\n      populate.forEach(function (field) {\n        if (error) return;\n        if (checkBadSelection(field.path || field)) {\n          return error = RestError.Forbidden('Including excluded fields is not permitted');\n        }\n        // Don't allow selecting fields from client when populating\n        if (field.select) {\n\t  if (!allowPopulateSelect) return error = RestError.Forbidden('Selecting fields of populated documents is not permitted');\n\t  console.warn('WARNING: Allowing populate with select is experimental and bypasses security.');\n        }\n\n        request.baucis.query.populate(field);\n      });\n    }\n\n    next(error);\n  });\n  // Apply incoming request skip.\n  this.query(function (request, response, next) {\n    var skip = request.query.skip;\n    if (skip === undefined || skip === null) return next();\n    if (!isNonNegativeInteger(skip)) {\n      return next(RestError.BadRequest('Skip must be a non-negative integer if set'));\n    }\n    request.baucis.query.skip(getAsInt(skip));\n    next();\n  });\n  // Apply incoming request limit.\n  this.query(function (request, response, next) {\n    var limit = request.query.limit;\n    if (limit === undefined || limit === null) return next();\n    if (!isPositiveInteger(limit)) {\n      return next(RestError.BadRequest('Limit must be a positive integer if set'));\n    }\n    request.baucis.query.limit(getAsInt(limit));\n    next();\n  });\n  // Set count flag.\n  this.query(function (request, response, next) {\n    if (!request.query.count) return next();\n    if (request.query.count === 'false') return next();\n    if (request.query.count !== 'true') {\n      next(RestError.BadRequest('Count must be \"true\" or \"false\" if set'));\n      return;\n    }\n\n    if (request.query.hint) {\n      next(RestError.BadRequest('Hint can\\'t be used with count'));\n      return;\n    }\n\n    if (request.query.comment) {\n      next(RestError.BadRequest('Comment can\\'t be used with count'));\n      return;\n    }\n\n    request.baucis.count = true;\n    next();\n  });\n  // Check for query comment.\n  this.query(function (request, response, next) {\n    var comment = request.query.comment;\n    if (!comment) return next();\n    if (controller.comments()) request.baucis.query.comment(comment);\n    else console.warn('Query comment was ignored.');\n    next();\n  });\n  // Check for query hint.\n  this.query(function (request, response, next) {\n    var hint = request.query.hint;\n\n    if (!hint) return next();\n    if (!controller.hints()) {\n      return next(RestError.Forbidden('Hints are not enabled for this resource'));\n    }\n\n    if (typeof hint === 'string') hint = JSON.parse(hint);\n    // Convert the value for each path from stirng to number.\n    Object.keys(hint).forEach(function (path) {\n      hint[path] = Number(hint[path]);\n    });\n    request.baucis.query.hint(hint);\n\n    next();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/send.js":"// __Dependencies__\nvar es = require('event-stream');\nvar crypto = require('crypto');\nvar RestError = require('rest-error');\n\n// __Module Definition__\nvar decorator = module.exports = function (options, protect) {\n  var baucis = require('..');\n  var controller = this;\n  var lastModifiedPath = controller.model().lastModified();\n  var trailers = {};\n\n  // __Private Module Members__\n  // Format the Trailer header.\n  function addTrailer (response, header) {\n    var current = response.get('Trailer');\n    if (!current) response.set('Trailer', header);\n    else response.set('Trailer', current + ', ' + header);\n  }\n  // A map that is used to create empty response body.\n  function empty (context, callback) { callback(null, '') }\n  // Map contexts back into documents.\n  function redoc (context, callback) { callback(null, context.doc) }\n  // Generate a respone Etag from a context.\n  function etag (response, useTrailer) {\n    if (useTrailer) {\n      addTrailer(response, 'Etag');\n      response.set('Transfer-Encoding', 'chunked');\n    }\n\n    var hash = crypto.createHash('md5');\n\n    return es.through(function (chunk) {\n      hash.update(chunk);\n      this.emit('data', chunk);\n    },\n    function () {\n      if (useTrailer) {\n        trailers.Etag = '\"' + hash.digest('hex') + '\"';\n      }\n      else {\n        response.set('Etag', '\"' + hash.digest('hex') + '\"');\n      }\n\n      this.emit('end');\n    });\n  }\n\n  function etagImmediate (response) {\n    var hash = crypto.createHash('md5');\n\n    return es.through(function (chunk) {\n      hash.update(JSON.stringify(chunk));\n      response.set('Etag', '\"' + hash.digest('hex') + '\"');\n      this.emit('data', chunk);\n    },\n    function () {\n      this.emit('end');\n    });\n  }\n  // Generate a Last-Modified header/trailer\n  function lastModified (response, useTrailer) {\n    if (useTrailer) {\n      addTrailer(response, 'Last-Modified');\n      response.set('Transfer-Encoding', 'chunked');\n    }\n\n    var latest = null;\n\n    return es.through(function (context) {\n      if (!context) return;\n      if (!context.doc) return this.emit('data', context);\n      if (!context.doc.get) return this.emit('data', context);\n\n      var current = context.doc.get(lastModifiedPath);\n      if (latest === null) latest = current;\n      else latest = new Date(Math.max(latest, current));\n      if (!useTrailer) {\n        response.set('Last-Modified', latest.toUTCString());\n      }\n      this.emit('data', context);\n    },\n    function () {\n      if (useTrailer) {\n        if (latest) trailers['Last-Modified'] = latest.toUTCString();\n      }\n\n      this.emit('end');\n    });\n  }\n\n  // Build a reduce stream.\n  function reduce (accumulated, f) {\n    return es.through(\n      function (context) {\n        accumulated = f(accumulated, context);\n      },\n      function () {\n        this.emit('data', accumulated);\n        this.emit('end');\n      }\n    );\n  }\n  // Count emissions.\n  function count () {\n    return reduce(0, function (a, b) { return a + 1 });\n  }\n\n  // If counting get the count and send it back directly.\n  protect.finalize(function (request, response, next) {\n    if (!request.baucis.count) return next();\n\n    request.baucis.query.count(function (error, n) {\n      if (error) return next(error);\n      response.removeHeader('Transfer-Encoding');\n      return response.json(n); // TODO support other content types\n    });\n  });\n\n  // If not counting, create the basic stream pipeline.\n  protect.finalize('collection', 'all',function (request, response, next) {\n    var count = 0;\n    var documents = request.baucis.documents;\n    var pipeline = request.baucis.send = protect.pipeline(next);\n    // If documents were set in the baucis hash, use them.\n    if (documents) pipeline(es.readArray([].concat(documents)));\n    // Otherwise, stream the relevant documents from Mongo, based on constructed query.\n    else pipeline(request.baucis.query.stream());\n    // Map documents to contexts.\n    pipeline(function (doc, callback) {\n      callback(null, { doc: doc, incoming: null });\n    });\n    // Check for not found.\n    pipeline(es.through(\n      function (context) {\n        count += 1;\n        this.emit('data', context);\n      },\n      function () {\n        if (count > 0) return this.emit('end');\n\n        var status = controller.emptyCollection();\n        response.status(status);\n\n        if (status === 204) return this.emit('end');\n        if (status === 200) {\n          response.removeHeader('Transfer-Encoding');\n          response.json([]); // TODO other content types\n          this.emit('end');\n          return;\n        }\n\n        this.emit('error', RestError.NotFound());\n      }\n    ));\n    // Apply user streams.\n    pipeline(request.baucis.outgoing());\n\n    // Set the document formatter based on the Accept header of the request.\n    baucis.formatters(response, function (error, formatter) {\n      if (error) return next(error);\n      request.baucis.formatter = formatter;\n      next();\n    });\n  });\n\n  protect.finalize('instance', 'all', function (request, response, next) {\n    var count = 0;\n    var documents = request.baucis.documents;\n    var pipeline = request.baucis.send = protect.pipeline(next);\n    // If documents were set in the baucis hash, use them.\n    if (documents) pipeline(es.readArray([].concat(documents)));\n    // Otherwise, stream the relevant documents from Mongo, based on constructed query.\n    else pipeline(request.baucis.query.stream());\n    // Map documents to contexts.\n    pipeline(function (doc, callback) {\n      callback(null, { doc: doc, incoming: null });\n    });\n    // Check for not found.\n    pipeline(es.through(\n      function (context) {\n        count += 1;\n        this.emit('data', context);\n      },\n      function () {\n        if (count > 0) return this.emit('end');\n        this.emit('error', RestError.NotFound());\n      }\n    ));\n    // Apply user streams.\n    pipeline(request.baucis.outgoing());\n\n    // Set the document formatter based on the Accept header of the request.\n    baucis.formatters(response, function (error, formatter) {\n      if (error) return next(error);\n      request.baucis.formatter = formatter;\n      next();\n    });\n  });\n\n  // OPTIONS // TODO Express' extra handling for OPTIONS conflicts with baucis\n  // TODO maybe send method names in body\n  // controller.options(function (request, response, next) {\n  //   console.log('here')\n  //   request.baucis.send(empty);\n  //   next();\n  // });\n\n  // HEAD\n  protect.finalize('instance', 'head', function (request, response, next) {\n    if (lastModifiedPath) {\n      request.baucis.send(lastModified(response, false));\n    }\n\n    request.baucis.send(redoc);\n    request.baucis.send(etagImmediate(response));\n    request.baucis.send(request.baucis.formatter());\n    request.baucis.send(empty);\n    next();\n  });\n\n  protect.finalize('collection', 'head', function (request, response, next) {\n    if (lastModifiedPath) {\n      request.baucis.send(lastModified(response, false));\n    }\n\n    request.baucis.send(redoc);\n    request.baucis.send(request.baucis.formatter(true));\n    request.baucis.send(etag(response, false));\n    request.baucis.send(empty);\n    next();\n  });\n\n  // GET\n  protect.finalize('instance', 'get', function (request, response, next) {\n    if (lastModifiedPath) {\n      request.baucis.send(lastModified(response, false));\n    }\n\n    request.baucis.send(redoc);\n    request.baucis.send(etagImmediate(response));\n    request.baucis.send(request.baucis.formatter());\n    next();\n  });\n\n  protect.finalize('collection', 'get', function (request, response, next) {\n    if (lastModifiedPath) {\n      request.baucis.send(lastModified(response, true));\n    }\n\n    if (request.baucis.count) {\n      request.baucis.send(count());\n      request.baucis.send(es.stringify());\n    }\n    else {\n      request.baucis.send(redoc);\n      request.baucis.send(request.baucis.formatter(true));\n    }\n\n    request.baucis.send(etag(response, true));\n    next();\n  });\n\n  // POST\n  protect.finalize('collection', 'post', function (request, response, next) {\n    request.baucis.send(redoc);\n    request.baucis.send(request.baucis.formatter());\n    next();\n  });\n\n  // PUT\n  protect.finalize('put', function (request, response, next) {\n    request.baucis.send(redoc);\n    request.baucis.send(request.baucis.formatter());\n    next();\n  });\n\n  // DELETE\n  protect.finalize('delete', function (request, response, next) {\n    // Remove each document from the database.\n    request.baucis.send(function (context, callback) { context.doc.remove(callback) });\n    // Respond with the count of deleted documents.\n    request.baucis.send(count());\n    request.baucis.send(es.stringify());\n    next();\n  });\n\n  protect.finalize(function (request, response, next) {\n    request.baucis.send().pipe(es.through(function (chunk) {\n      response.write(chunk);\n    }, function () {\n      response.addTrailers(trailers);\n      response.end();\n      this.emit('end');\n    }));\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Controller/errors.js":"// __Dependencies__\nvar es = require('event-stream');\nvar util = require('util');\nvar mongoose = require('mongoose');\nvar RestError = require('rest-error');\n\n// __Module Definition__\nvar decorator = module.exports = function (options, protect) {\n  var baucis = require('..');\n  var controller = this;\n  // A controller property used to set what error status code\n  // and response is sent when a query to a collection endpoint\n  // yields no documents.\n  protect.property('emptyCollection', 200);\n  // A controller property that sets whether errors should be\n  // handled if possible, or just set status code.\n  protect.property('handleErrors', true, function (handle) {\n    return handle ? true : false;\n  });\n  // If it's a Mongo bad hint error, convert to a bad request error.\n  protect.use(function (error, request, response, next) {\n    if (!error) return next();\n    if (!error.message) return next(error);\n\n    var message = 'The requested query hint is invalid'\n    // Bad Mongo query hint (2.x).\n    if (error.message === 'bad hint') {\n      next(RestError.BadRequest(message));\n      return;\n    }\n    // Bad Mongo query hint (3.x).\n    if (error.message.match('planner returned error: bad hint')) {\n      next(RestError.BadRequest(message));\n      return;\n    }\n    if (!error.$err) return next(error);\n    // Mongoose 3\n    if (error.$err.match('planner returned error: bad hint')) {\n      next(RestError.BadRequest(message));\n      return;\n    }\n    next(error);\n  });\n  // Convert Mongo duplicate key error to an unprocessible entity error\n  protect.use(function (error, request, response, next) {\n    if (!error) return next();\n    if (!error.message) return next(error);\n    if (error.message.indexOf('E11000 duplicate key error') === -1) {\n      next(error);\n      return;\n    }\n\n    var body = {};\n    var scrape = /[$](.+)[_]\\d+\\s+dup key: [{] : \"([^\"]+)\" [}]/;\n    var scraped = scrape.exec(error.message);\n    var path = scraped ? scraped[1] : '???';\n    var value = scraped ? scraped[2] : '???';\n    body[path] = {\n      message: util.format('Path `%s` (%s) must be unique.', path, value),\n      originalMessage: error.message,\n      name: 'MongoError',\n      path: path,\n      type: 'unique',\n      value: value\n    };\n\n    var translatedError = RestError.UnprocessableEntity();\n    translatedError.errors = body;\n\n    next(translatedError);\n  });\n  // Convert Mongo validation errors to unprocessable entity errors.\n  protect.use(function (error, request, response, next) {\n    if (!error) return next();\n    if (!(error instanceof mongoose.Error.ValidationError)) return next(error);\n    var newError = RestError.UnprocessableEntity();\n    newError.errors = error.errors;\n    next(newError);\n  });\n  // Convert Mongoose version conflict error to LockConflict.\n  protect.use(function (error, request, response, next) {\n    if (!error) return next();\n    if (!(error instanceof mongoose.Error.VersionError)) return next(error);\n    next(RestError.LockConflict());\n  });\n  // Translate other errors to internal server errors.\n  protect.use(function (error, request, response, next) {\n    if (!error) return next();\n    if (error instanceof RestError) return next(error);\n    var error2 = RestError.InternalServerError(error.message);\n    error2.stack = error.stack;\n    next(error2);\n  });\n  // Format the error based on the Accept header.\n  protect.use(function (error, request, response, next) {\n    if (!error) return next();\n\n    // Always set the status code if available.\n    if (error.status >= 100) {\n      response.status(error.status);\n    }\n\n    if (!controller.handleErrors()) return next(error);\n\n    baucis.formatters(response, function (error2, formatter) {\n      if (error2) return next(error2);\n\n      var errors;\n\n      if (!error.errors) {\n        errors = [error];\n      }\n      else if (Array.isArray(error.errors) && error.errors.length !== 0) {\n        errors = error.errors;\n      }\n      else {\n        errors = Object.keys(error.errors).map(function (key) {\n          return error.errors[key]\n        });\n      }\n\n      if (errors.length === 0) {\n        errors = [error];\n      }\n\n      errors = errors.map(function (error3) {\n        var o = {};\n        Object.getOwnPropertyNames(error3).forEach(function(key) {\n          o[key] = error3[key];\n        });\n        delete o.domain;\n        delete o.domainEmitter;\n        delete o.domainThrown;\n        return o;\n      });\n\n      // TODO deprecated -- always send as single error in 2.0.0\n      var f = formatter(error instanceof RestError.UnprocessableEntity);\n      f.on('error', next);\n\n      es.readArray(errors).pipe(f).pipe(response);\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis/Api/controllers.js":"// __Dependencies__\nvar util = require('util');\nvar semver = require('semver');\nvar RestError = require('rest-error');\n\n// __Module Definition__\nvar plugin = module.exports = function (options, protect) {\n  var api = this;\n  var controllers = [];\n\n  // __Public Instance Members__\n  // Add a controller to the API.\n  api.add = function (controller) {\n    controllers.push(controller);\n    return api;\n  };\n  // Return a copy of the controllers array, optionally filtered by release.\n  protect.controllers = function (release, fragment) {\n    var all = [].concat(controllers);\n\n    if (!release) return all;\n\n    var satisfies = all.filter(function (controller) {\n      return semver.satisfies(release, controller.versions());\n    });\n\n    if (!fragment) {\n      return satisfies;\n    }\n\n    // Find the matching controller among controllers that match the requested release.\n    return satisfies.filter(function (controller) {\n      return fragment === controller.fragment();\n    });\n  };\n  // Find the correct controller to handle the request.\n  api.use('/:path', function (request, response, next) {\n    var fragment = '/' + request.params.path;\n    var controllers = protect.controllers(request.baucis.release, fragment);\n    // If not found, bail.\n    if (controllers.length === 0) return next();\n\n    request.baucis.controller = controllers[0];\n    request.baucis.controller(request, response, next);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis-json/index.js":"// __Dependencies__\nvar es = require('event-stream');\n\n// __Module Definition__\nvar plugin = module.exports = function () {\n  var baucis = this;\n\n  // __Private Methods__\n  // Default formatter  emit a single JSON object or an array of them.\n  function singleOrArray (alwaysArray) {\n    var first = false;\n    var multiple = false;\n\n    return es.through(\n      function (doc) {\n        // Start building the output.  If this is the first document,\n        // store it for a moment.\n        if (!first) {\n          first = doc;\n          return;\n        }\n        // If this is the second document, output array opening and the two documents\n        // separated by a comma.\n        if (!multiple) {\n          multiple = true;\n          this.emit('data', '[');\n          this.emit('data', JSON.stringify(first));\n          this.emit('data', ',\\n')\n          this.emit('data', JSON.stringify(doc));\n          return;\n        }\n        // For all documents after the second, emit a comma preceding the document.\n        this.emit('data', ',\\n');\n        this.emit('data', JSON.stringify(doc));\n      },\n      function () {\n        // If no documents, simply end the stream.\n        if (!first) return this.emit('end');\n        // If only one document emit it unwrapped, unless always returning an array.\n        if (!multiple && alwaysArray) this.emit('data', '[');\n        if (!multiple) this.emit('data', JSON.stringify(first));\n        // For greater than one document, emit the closing array.\n        else this.emit('data', ']');\n        if (!multiple && alwaysArray) this.emit('data', ']');\n        // Done.  End the stream.\n        this.emit('end');\n      }\n    );\n  };\n\n  // Default parser.  Parses incoming JSON string into an object or objects.\n  // Works whether an array or single object is sent as the request body.  It's\n  // very lenient with input outside of first-level braces.  This means that\n  // a collection of JSON objects can be sent in different ways e.g. separated\n  // by whitespace or in a fully JSON-compatible array with objects split by \n  // commas.\n  function JSONParser () {\n    var depth = 0;\n    var buffer = '';\n\n    return es.through(function (chunk) {\n      var match;\n      var head;\n      var brace;\n      var tail;\n      var emission;\n      var remaining = chunk.toString();\n      while (remaining !== '') {\n        match = remaining.match(/[\\}\\{]/);\n        // The head of the string is all characters up to the first brace, if any.\n        head = match ? remaining.substr(0, match.index) : remaining;\n        // The first brace in the string, if any.\n        brace = match ? match[0] : '';\n        // The rest of the string, following the brace.\n        tail = match ? remaining.substr(match.index + 1) : '';\n\n        if (depth === 0) {\n          // The parser is outside an object.\n          // Ignore the head of the string.\n          // Add brace if it's an open brace.\n          if (brace === '{') {\n            depth += 1;\n            buffer += brace;\n          }\n        }\n        else {\n          // The parser is inside an object.\n          // Add the head of the string to the buffer.\n          buffer += head;\n          // Increase or decrease depth if a brace was found.\n          if (brace === '{') depth += 1;\n          else if (brace === '}') depth -= 1;\n          // Add the brace to the buffer.\n          buffer += brace;\n          // If the object ended, emit it.\n          if (depth === 0) {\n            try {\n              emission = JSON.parse(buffer);\n            }\n            catch (error) {\n              this.emit('error', baucis.Error.BadSyntax('The body of this request was invalid and could not be parsed. \"%s\"', error.message));\n            }\n\n            this.emit('data', emission);\n            buffer = '';\n          }\n        }\n        // Move on to the unprocessed remainder of the string.\n        remaining = tail;\n      }\n    });\n  }\n\n  // Add a JSON formatter and parser.\n  baucis.setFormatter('application/json', singleOrArray);\n  baucis.setParser('application/json', JSONParser);\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis-json/node_modules/event-stream/index.js":"//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\nvar Stream = require('stream').Stream\n  , es = exports\n  , through = require('through')\n  , from = require('from')\n  , duplex = require('duplexer')\n  , map = require('map-stream')\n  , pause = require('pause-stream')\n  , split = require('split')\n  , pipeline = require('stream-combiner')\n  , immediately = global.setImmediate || process.nextTick;\n\nes.Stream = Stream //re-export Stream from core\nes.through = through\nes.from = from\nes.duplex = duplex\nes.map = map\nes.pause = pause\nes.split = split\nes.pipeline = es.connect = es.pipe = pipeline\n// merge / concat\n//\n// combine multiple streams into a single stream.\n// will emit end only once\n\nes.concat = //actually this should be called concat\nes.merge = function (/*streams...*/) {\n  var toMerge = [].slice.call(arguments)\n  var stream = new Stream()\n  stream.setMaxListeners(0) // allow adding more than 11 streams\n  var endCount = 0\n  stream.writable = stream.readable = true\n\n  toMerge.forEach(function (e) {\n    e.pipe(stream, {end: false})\n    var ended = false\n    e.on('end', function () {\n      if(ended) return\n      ended = true\n      endCount ++\n      if(endCount == toMerge.length)\n        stream.emit('end') \n    })\n  })\n  stream.write = function (data) {\n    this.emit('data', data)\n  }\n  stream.destroy = function () {\n    toMerge.forEach(function (e) {\n      if(e.destroy) e.destroy()\n    })\n  }\n  return stream\n}\n\n\n// writable stream, collects all events into an array \n// and calls back when 'end' occurs\n// mainly I'm using this to test the other functions\n\nes.writeArray = function (done) {\n  if ('function' !== typeof done)\n    throw new Error('function writeArray (done): done must be function')\n\n  var a = new Stream ()\n    , array = [], isDone = false\n  a.write = function (l) {\n    array.push(l)\n  }\n  a.end = function () {\n    isDone = true\n    done(null, array)\n  }\n  a.writable = true\n  a.readable = false\n  a.destroy = function () {\n    a.writable = a.readable = false\n    if(isDone) return\n    done(new Error('destroyed before end'), array)\n  }\n  return a\n}\n\n//return a Stream that reads the properties of an object\n//respecting pause() and resume()\n\nes.readArray = function (array) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n    , ended = false\n \n  stream.readable = true  \n  stream.writable = false\n \n  if(!Array.isArray(array))\n    throw new Error('event-stream.read expects an array')\n  \n  stream.resume = function () {\n    if(ended) return\n    paused = false\n    var l = array.length\n    while(i < l && !paused && !ended) {\n      stream.emit('data', array[i++])\n    }\n    if(i == l && !ended)\n      ended = true, stream.readable = false, stream.emit('end')\n  }\n  process.nextTick(stream.resume)\n  stream.pause = function () {\n     paused = true\n  }\n  stream.destroy = function () {\n    ended = true\n    stream.emit('close')\n  }\n  return stream\n}\n\n//\n// readable (asyncFunction)\n// return a stream that calls an async function while the stream is not paused.\n//\n// the function must take: (count, callback) {...\n//\n\nes.readable =\nfunction (func, continueOnError) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n    , ended = false\n    , reading = false\n\n  stream.readable = true  \n  stream.writable = false\n \n  if('function' !== typeof func)\n    throw new Error('event-stream.readable expects async function')\n  \n  stream.on('end', function () { ended = true })\n  \n  function get (err, data) {\n    \n    if(err) {\n      stream.emit('error', err)\n      if(!continueOnError) stream.emit('end')\n    } else if (arguments.length > 1)\n      stream.emit('data', data)\n\n    immediately(function () {\n      if(ended || paused || reading) return\n      try {\n        reading = true\n        func.call(stream, i++, function () {\n          reading = false\n          get.apply(null, arguments)\n        })\n      } catch (err) {\n        stream.emit('error', err)    \n      }\n    })\n  }\n  stream.resume = function () {\n    paused = false\n    get()\n  }\n  process.nextTick(get)\n  stream.pause = function () {\n     paused = true\n  }\n  stream.destroy = function () {\n    stream.emit('end')\n    stream.emit('close')\n    ended = true\n  }\n  return stream\n}\n\n\n//\n// map sync\n//\n\nes.mapSync = function (sync) { \n  return es.through(function write(data) {\n    var mappedData = sync(data)\n    if (typeof mappedData !== 'undefined')\n      this.emit('data', mappedData)\n  })\n}\n\n//\n// log just print out what is coming through the stream, for debugging\n//\n\nes.log = function (name) {\n  return es.through(function (data) {\n    var args = [].slice.call(arguments)\n    if(name) console.error(name, data)\n    else     console.error(data)\n    this.emit('data', data)\n  })\n}\n\n\n//\n// child -- pipe through a child process\n//\n\nes.child = function (child) {\n\n  return es.duplex(child.stdin, child.stdout)\n\n}\n\n//\n// parse\n//\n// must be used after es.split() to ensure that each chunk represents a line\n// source.pipe(es.split()).pipe(es.parse())\n\nes.parse = function (options) {\n  var emitError = !!(options ? options.error : false)\n  return es.through(function (data) {\n    var obj\n    try {\n      if(data) //ignore empty lines\n        obj = JSON.parse(data.toString())\n    } catch (err) {\n      if (emitError)\n        return this.emit('error', err)\n      return console.error(err, 'attemping to parse:', data)\n    }\n    //ignore lines that where only whitespace.\n    if(obj !== undefined)\n      this.emit('data', obj)\n  })\n}\n//\n// stringify\n//\n\nes.stringify = function () { \n  var Buffer = require('buffer').Buffer\n  return es.mapSync(function (e){ \n    return JSON.stringify(Buffer.isBuffer(e) ? e.toString() : e) + '\\n'\n  }) \n}\n\n//\n// replace a string within a stream.\n//\n// warn: just concatenates the string and then does str.split().join(). \n// probably not optimal.\n// for smallish responses, who cares?\n// I need this for shadow-npm so it's only relatively small json files.\n\nes.replace = function (from, to) {\n  return es.pipeline(es.split(from), es.join(to))\n} \n\n//\n// join chunks with a joiner. just like Array#join\n// also accepts a callback that is passed the chunks appended together\n// this is still supported for legacy reasons.\n// \n\nes.join = function (str) {\n  \n  //legacy api\n  if('function' === typeof str)\n    return es.wait(str)\n\n  var first = true\n  return es.through(function (data) {\n    if(!first)\n      this.emit('data', str)\n    first = false\n    this.emit('data', data)\n    return true\n  })\n}\n\n\n//\n// wait. callback when 'end' is emitted, with all chunks appended as string.\n//\n\nes.wait = function (callback) {\n  var arr = []\n  return es.through(function (data) { arr.push(data) },\n    function () {\n      var body = Buffer.isBuffer(arr[0]) ? Buffer.concat(arr)\n        : arr.join('')\n      this.emit('data', body)\n      this.emit('end')\n      if(callback) callback(null, body)\n    })\n}\n\nes.pipeable = function () {\n  throw new Error('[EVENT-STREAM] es.pipeable is deprecated')\n}\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis-links/index.js":"'use strict';\n\nvar middleware = require('./middleware');\n\n// __Module Definition__\nvar decorator = module.exports = function () {\n  var baucis = this;\n  baucis.Controller.decorators(middleware);\n};\n","/home/travis/build/npmtest/node-npmtest-baucis/node_modules/baucis-links/middleware.js":"'use strict';\n\n// __Dependencies__\nvar url = require('url');\nvar deco = require('deco');\nvar qs = require('querystring');\n\n// __Module Definition__\nvar decorator = module.exports = function (options, protect) {\n  var controller = this;\n\n  protect.property('relations', true);\n\n  // Calculate basic links for instance routes.\n  controller.query('instance', '*', function (request, response, next) {\n    if (controller.relations() === false) return next();\n\n    var originalPath = request.originalUrl.split('?')[0];\n    var originalPathParts = originalPath.split('/');\n    var linkBase;\n\n    originalPathParts.pop();\n    linkBase = originalPathParts.join('/');\n\n    request.baucis.links = {\n      collection: linkBase,\n      search: linkBase,\n      edit: linkBase + '/' + request.params.id,\n      self: originalPath\n    };\n\n    next();\n  });\n\n  // Calculate basic links for collection routes.\n  controller.query('collection', '*', function (request, response, next) {\n    if (controller.relations() === false) return next();\n\n    var originalPath = request.originalUrl.split('?')[0];\n    // Used to create a link from current URL with new query string.\n    var makeLink = function (query) {\n      var newQuery = deco.merge(request.query, query);\n      return originalPath + '?' + qs.stringify(newQuery);\n    };\n    // Response Link header links.\n    var links = { search: originalPath, self: makeLink() };\n    // Call this function to set response links then move on to next middleware.\n    var done = function () { request.baucis.links = links, next() };\n\n    // Add paging links unless these conditions are met.\n    if (request.method !== 'GET') return done();\n    if (!request.query.limit) return done();\n\n    controller.model().count(request.baucis.conditions, function (error, count) {\n      if (error) return next(error);\n\n      var limit = Number(request.query.limit);\n      var skip = Number(request.query.skip || 0);\n\n      links.first = makeLink({ skip: 0 });\n      links.last = makeLink({ skip: Math.max(0, count - limit) });\n\n      if (skip) links.previous = makeLink({ skip: Math.max(0, skip - limit) });\n      if (limit + skip < count) links.next = makeLink({ skip: limit + skip });\n\n      done();\n    });\n  });\n\n  // Add \"Link\" header field based on previously set links.\n  controller.query(function (request, response, next) {\n    if (controller.relations() === false) return next();\n    if (!request.baucis.links) return next();\n    response.links(request.baucis.links);\n    next();\n  });\n};\n"}